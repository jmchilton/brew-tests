#!/usr/bin/env python

# % vbrew vinstall homebrew/science/samtools 1.0
# % vbrew vinstall homebrew/science/samtools 0.1.19
# % vbrew vinstall homebrew/science/samtools 1.1
# % vbrew env homebrew/science/samtools 1.1
# PATH=/home/john/.linuxbrew/Cellar/htslib/1.1/bin:/home/john/.linuxbrew/Cellar/samtools/1.1/bin:$PATH
# export PATH
# LD_LIBRARY_PATH=/home/john/.linuxbrew/Cellar/htslib/1.1/lib:/home/john/.linuxbrew/Cellar/samtools/1.1/lib:$LD_LIBRARY_PATH
# export LD_LIBRARY_PATH
# % . <(vbrew env homebrew/science/samtools 1.1)
# % which samtools
# /home/john/.linuxbrew/Cellar/samtools/1.1/bin/samtools
# % . <(vbrew env homebrew/science/samtools 0.1.19)
# % which samtools
# /home/john/.linuxbrew/Cellar/samtools/0.1.19/bin/samtools
# % vbrew vuninstall samtools 1.0
# % vbrew vdeps samtools 1.1
# htslib@1.1
# % vbrew vdeps samtools 0.1.19

import argparse
import contextlib
import json
import os
import re
import sys
import subprocess

WHITESPACE_PATTERN = re.compile("[\s]+")

DESCRIPTION = "Script built on top of linuxbrew to operate on isolated, versioned brew installed environments."

if sys.platform == "darwin":
    DEFAULT_HOMEBREW_ROOT = "/usr/local"
else:
    DEFAULT_HOMEBREW_ROOT = os.path.join(os.path.expanduser("~"), ".linuxbrew")

NO_BREW_ERROR_MESSAGE = "Could not find brew on PATH, please place on path or pass to script with --brew argument."


class BrewContext(object):

    def __init__(self, args):
        ensure_brew_on_path(args)
        raw_config = brew_execute(["config"])
        config_lines = [l.strip().split(":", 1) for l in raw_config.split("\n") if l]
        config = dict([(p[0].strip(), p[1].strip()) for p in config_lines])
        # unset if "/usr/local" -> https://github.com/Homebrew/homebrew/blob/master/Library/Homebrew/cmd/config.rb
        homebrew_prefix = config.get("HOMEBREW_PREFIX", "/usr/local")
        homebrew_cellar = config.get("HOMEBREW_CELLAR", os.path.join(homebrew_prefix, "Cellar"))
        self.homebrew_prefix = homebrew_prefix
        self.homebrew_cellar = homebrew_cellar


class RecipeContext(object):

    def __init__(self, args, brew_context):
        self.recipe = args.recipe
        self.version = args.version
        self.brew_context = brew_context

    @property
    def cellar_path(self):
        return recipe_cellar_path(self.brew_context.homebrew_cellar, self.recipe, self.version)

    @property
    def tap_path(self):
        return os.path.join(self.brew_context.homebrew_prefix, "Library", "Taps", self.__tap_path(self.recipe))

    def __tap_path(self, recipe):
        parts = recipe.split("/")
        assert len(parts) == 3
        path = os.path.join(parts[0], "homebrew-%s" % parts[1])
        return path


def main():
    parser = argparse.ArgumentParser(description=DESCRIPTION)
    parser.add_argument("--brew", help="Path to linuxbrew 'brew' executable to target")
    actions = ["vinstall", "vuninstall", "vdeps", "vinfo", "env"]
    parser.add_argument('action', metavar='action', help="Versioned action to perform.", choices=actions)
    parser.add_argument('recipe', metavar='recipe', help="Recipe for action - should be absolute (e.g. homebrew/science/samtools).")
    parser.add_argument('version', metavar='version', help="Version for action (e.g. 0.1.19).")
    args = parser.parse_args()
    action = args.action
    brew_context = BrewContext(args)
    recipe_context = RecipeContext(args, brew_context)
    if action == "vinstall":
        versioned_install(recipe_context, args.recipe, args.version)
    elif action == "vuninstall":
        brew_execute(["switch", args.recipe, args.version])
        brew_execute(["uninstall", args.recipe])
    elif action == "vdeps":
        print_versioned_deps(recipe_context, args.recipe, args.version)
    elif action == "env":
        deps = load_versioned_deps(recipe_context, args.recipe, args.version)
        deps.append({"name": args.recipe, "version": args.version, "versioned": True})
        env_statements = build_env_statements(recipe_context, deps)
        print env_statements
    else:
        raise NotImplementedError()


class CommandLineException(Exception):

    def __init__(self, command, stdout, stderr):
        self.command = command
        self.stdout = stdout
        self.stderr = stderr
        self.message = ("Failed to execute command-line %s, stderr was:\n"
                        "-------->>begin stderr<<--------\n"
                        "%s\n"
                        "-------->>end stderr<<--------\n") % (command, stderr)

    def __str__(self):
        return self.message


def versioned_install(recipe_context, package, version=None):
    tap_path = recipe_context.tap_path
    with brew_changeset("master", tap_path):
        version_to_changeset = brew_version_info(package, recipe_context.tap_path)
        if version is None:
            version = version_to_changeset[0][0]
            changeset = version_to_changeset[0][1]
        else:
            for mapping in version_to_changeset:
                if mapping[0] == version:
                    changeset = mapping[1]
        attempt_unlink(package)
        with brew_changeset(changeset, tap_path):
            deps = brew_deps(package)
            deps_metadata = []
            dep_to_version = {}
            for dep in deps:
                version_info = brew_version_info(dep, recipe_context.tap_path)[0]
                dep_version = version_info[0]
                dep_to_version[dep] = dep_version
                versioned = version_info[2]
                if versioned:
                    dep_to_version[dep] = dep_version
                    versioned_install(recipe_context, dep, dep_version)
                else:
                    # Install latest.
                    dep_to_version[dep] = None
                    unversioned_install(dep)
                dep_metadata = {
                    'name': dep,
                    'version': dep_version,
                    'versioned': versioned
                }
                deps_metadata.append(dep_metadata)
            try:
                for dep in deps:
                    dep_version = dep_to_version[dep]
                    if dep_version:
                        brew_execute(["switch", dep, dep_version])
                    else:
                        brew_execute(["link", dep])

                brew_execute(["install", package])
                deps = brew_execute(["deps", package])
                deps = [d.strip() for d in deps.split("\n") if d]
                metadata = {
                    'deps': deps_metadata
                }
                cellar_root = recipe_context.brew_context.homebrew_cellar
                cellar_path = recipe_cellar_path( cellar_root, package, version )
                v_metadata_path = os.path.join(cellar_path, "INSTALL_RECEIPT_VERSIONED.json")
                with open(v_metadata_path, "w") as f:
                    json.dump(metadata, f)

            finally:
                attempt_unlink_all(package, deps)


def print_versioned_deps(recipe_context, recipe, version):
    deps = load_versioned_deps(recipe_context, recipe, version)
    for dep in deps:
        val = dep['name']
        if dep['versioned']:
            val += "@%s" % dep['version']
        print val


def load_versioned_deps(recipe_context, recipe, version):
    cellar_path = recipe_context.cellar_path
    v_metadata_path = os.path.join(cellar_path, "INSTALL_RECEIPT_VERSIONED.json")
    if not os.path.isfile(v_metadata_path):
        raise IOError("Could not locate versioned receipt file: {}".format(v_metadata_path))
    with open(v_metadata_path, "r") as f:
        metadata = json.load(f)
    return metadata['deps']


def unversioned_install(package):
    try:
        deps = brew_deps(package)
        for dep in deps:
            brew_execute(["link", dep])
        brew_execute(["install", package])
    finally:
        attempt_unlink_all(package, deps)


def attempt_unlink_all(package, deps):
    for dep in deps:
        attempt_unlink(dep)
    attempt_unlink(package)


def attempt_unlink(package):
    try:
        brew_execute(["unlink", package])
    except Exception:
        # TODO: warn
        pass


def brew_execute(args):
    cmds = ["brew"] + args
    return execute(cmds)


def build_env_statements(recipe_context, deps):
    path_appends = []
    ld_path_appends = []
    for dep in deps:
        package = dep['name']
        version = dep['version']
        cellar_root = recipe_context.brew_context.homebrew_cellar
        cellar_path = recipe_cellar_path( cellar_root, package, version )
        bin_path = os.path.join(cellar_path, "bin")
        if os.path.isdir(bin_path):
            path_appends.append(bin_path)
        lib_path = os.path.join(cellar_path, "lib")
        if os.path.isdir(lib_path):
            ld_path_appends.append(lib_path)
    env_statements = []
    if path_appends:
        env_statements.append("PATH=" + ":".join(path_appends) + ":$PATH")
        env_statements.append("export PATH")
    if ld_path_appends:
        env_statements.append("LD_LIBRARY_PATH=" + ":".join(ld_path_appends) + ":$LD_LIBRARY_PATH")
        env_statements.append("export LD_LIBRARY_PATH")
    return "\n".join(env_statements)


@contextlib.contextmanager
def brew_changeset(changeset, tap_path):
    try:
        os.chdir(tap_path)
        current_changeset = git_execute(["rev-parse", "HEAD"]).strip()
        try:
            git_execute(["checkout", changeset])
            yield
        finally:
            git_execute(["checkout", current_changeset])
    finally:
        # TODO: restore chdir - or better yet just don't chdir
        # shouldn't be needed.
        pass


def git_execute(args):
    cmds = ["git"] + args
    return execute(cmds)


def execute(cmds):
    p = subprocess.Popen(cmds, shell=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = p.communicate()
    if p.returncode != 0:
        raise CommandLineException(" ".join(cmds), stdout, stderr)
    return stdout


def brew_deps(package):
    stdout = brew_execute(["deps", package])
    return [p.strip() for p in stdout.split("\n") if p]


def brew_version_info(package, tap_path):

    def versioned(recipe_path):
        if not os.path.isabs(recipe_path):
            recipe_path = os.path.join(os.getcwd(), recipe_path)
        # Dependencies in the same repository should be versioned,
        # core dependencies (presumably in base homebrew) are not
        # versioned.
        return tap_path in recipe_path

    # TODO: Also use tags.
    stdout = brew_execute(["versions", package])
    version_parts = [l for l in stdout.split("\n") if l and "git checkout" in l]
    version_parts = map(lambda l: WHITESPACE_PATTERN.split(l), version_parts)
    info = [(p[0], p[3], versioned(p[4])) for p in version_parts]
    return info


def recipe_cellar_path(cellar_path, recipe, version):
    recipe_base = recipe.split("/")[-1]
    return os.path.join(cellar_path, recipe_base, version)


def ensure_brew_on_path(args):
    brew_on_path = which("brew")
    if brew_on_path:
        brew_on_path = os.path.abspath(brew_on_path)

    def ensure_on_path(brew):
        if brew != brew_on_path:
            os.environ["PATH"] = "%s:%s" % (os.path.dirname(brew), os.environ["PATH"])

    default_brew_path = os.path.join(DEFAULT_HOMEBREW_ROOT, "bin", "brew")
    if args.brew:
        user_brew_path = os.path.abspath(args.brew)
        ensure_on_path(user_brew_path)
    elif brew_on_path:
        return brew_on_path
    elif os.path.exists(default_brew_path):
        ensure_on_path(default_brew_path)
    else:
        raise Exception(NO_BREW_ERROR_MESSAGE)


def which(file):
    # http://stackoverflow.com/questions/5226958/which-equivalent-function-in-python
    for path in os.environ["PATH"].split(":"):
        if os.path.exists(path + "/" + file):
                return path + "/" + file

    return None


if __name__ == "__main__":
    main()
